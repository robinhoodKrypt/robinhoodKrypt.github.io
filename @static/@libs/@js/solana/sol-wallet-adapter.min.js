/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/@project-serum/sol-wallet-adapter@0.2.6/dist/cjs/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
 var __extends = this && this.__extends || function() {
    var e = function(t, n) {
        return (e = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(e, t) {
                e.__proto__ = t
            } || function(e, t) {
                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
            })(t, n)
    };
    return function(t, n) {
        if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");

        function r() {
            this.constructor = t
        }
        e(t, n), t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}(),
__assign = this && this.__assign || function() {
    return (__assign = Object.assign || function(e) {
        for (var t, n = 1, r = arguments.length; n < r; n++)
            for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e
    }).apply(this, arguments)
},
__awaiter = this && this.__awaiter || function(e, t, n, r) {
    return new(n || (n = Promise))((function(i, o) {
        function s(e) {
            try {
                c(r.next(e))
            } catch (e) {
                o(e)
            }
        }

        function a(e) {
            try {
                c(r.throw(e))
            } catch (e) {
                o(e)
            }
        }

        function c(e) {
            var t;
            e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                e(t)
            }))).then(s, a)
        }
        c((r = r.apply(e, t || [])).next())
    }))
},
__generator = this && this.__generator || function(e, t) {
    var n, r, i, o, s = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    };
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(o) {
        return function(a) {
            return function(o) {
                if (n) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                    if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                    switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                        case 0:
                        case 1:
                            i = o;
                            break;
                        case 4:
                            return s.label++, {
                                value: o[1],
                                done: !1
                            };
                        case 5:
                            s.label++, r = o[1], o = [0];
                            continue;
                        case 7:
                            o = s.ops.pop(), s.trys.pop();
                            continue;
                        default:
                            if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                s = 0;
                                continue
                            }
                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                s.label = o[1];
                                break
                            }
                            if (6 === o[0] && s.label < i[1]) {
                                s.label = i[1], i = o;
                                break
                            }
                            if (i && s.label < i[2]) {
                                s.label = i[2], s.ops.push(o);
                                break
                            }
                            i[2] && s.ops.pop(), s.trys.pop();
                            continue
                    }
                    o = t.call(e, s)
                } catch (e) {
                    o = [6, e], r = 0
                } finally {
                    n = i = 0
                }
                if (5 & o[0]) throw o[1];
                return {
                    value: o[0] ? o[1] : void 0,
                    done: !0
                }
            }([o, a])
        }
    }
},
__read = this && this.__read || function(e, t) {
    var n = "function" == typeof Symbol && e[Symbol.iterator];
    if (!n) return e;
    var r, i, o = n.call(e),
        s = [];
    try {
        for (;
            (void 0 === t || t-- > 0) && !(r = o.next()).done;) s.push(r.value)
    } catch (e) {
        i = {
            error: e
        }
    } finally {
        try {
            r && !r.done && (n = o.return) && n.call(o)
        } finally {
            if (i) throw i.error
        }
    }
    return s
};


var PublicKey = solanaWeb3.PublicKey;



var Wallet = function(e) {
function t(t, n) {
    var r = e.call(this) || this;
    if (r._network = n, r._publicKey = null, r._popup = null, r._handlerAdded = !1, r._nextRequestId = 1, r._autoApprove = !1, r._responsePromises = new Map, r.handleMessage = function(e) {
            var t;
            if (r._injectedProvider && e.source === window || e.origin === (null === (t = r._providerUrl) || void 0 === t ? void 0 : t.origin) && e.source === r._popup)
                if ("connected" === e.data.method) {
                    var n = new PublicKey(e.data.params.publicKey);
                    r._publicKey && r._publicKey.equals(n) || (r._publicKey && !r._publicKey.equals(n) && r.handleDisconnect(), r._publicKey = n, r._autoApprove = !!e.data.params.autoApprove, r.emit("connect", r._publicKey))
                } else if ("disconnected" === e.data.method) r.handleDisconnect();
            else if (e.data.result || e.data.error) {
                var i = r._responsePromises.get(e.data.id);
                if (i) {
                    var o = __read(i, 2),
                        s = o[0],
                        a = o[1];
                    e.data.result ? s(e.data.result) : a(new Error(e.data.error))
                }
            }
        }, r._beforeUnload = function() {
            r.disconnect()
        }, isInjectedProvider(t)) r._injectedProvider = t;
    else {
        if (!isString(t)) throw new Error("provider parameter must be an injected provider or a URL string.");
        r._providerUrl = new URL(t), r._providerUrl.hash = new URLSearchParams({
            origin: window.location.origin,
            network: r._network
        }).toString()
    }
    return r
}
return __extends(t, e), t.prototype.handleConnect = function() {
    var e, t = this;
    return this._handlerAdded || (this._handlerAdded = !0, window.addEventListener("message", this.handleMessage), window.addEventListener("beforeunload", this._beforeUnload)), this._injectedProvider ? new Promise((function(e) {
        t.sendRequest("connect", {}), e()
    })) : (window.name = "parent", this._popup = window.open(null === (e = this._providerUrl) || void 0 === e ? void 0 : e.toString(), "_blank", "location,resizable,width=460,height=675"), new Promise((function(e) {
        t.once("connect", e)
    })))
}, t.prototype.handleDisconnect = function() {
    var e = this;
    this._handlerAdded && (this._handlerAdded = !1, window.removeEventListener("message", this.handleMessage), window.removeEventListener("beforeunload", this._beforeUnload)), this._publicKey && (this._publicKey = null, this.emit("disconnect")), this._responsePromises.forEach((function(t, n) {
        var r = __read(t, 2)[1];
        e._responsePromises.delete(n), r(new Error("Wallet disconnected"))
    }))
}, t.prototype.sendRequest = function(e, t) {
    return __awaiter(this, void 0, void 0, (function() {
        var n, r = this;
        return __generator(this, (function(i) {
            if ("connect" !== e && !this.connected) throw new Error("Wallet not connected");
            return n = this._nextRequestId, ++this._nextRequestId, [2, new Promise((function(i, o) {
                var s, a, c, u;
                r._responsePromises.set(n, [i, o]), r._injectedProvider ? r._injectedProvider.postMessage({
                    jsonrpc: "2.0",
                    id: n,
                    method: e,
                    params: __assign({
                        network: r._network
                    }, t)
                }) : (null === (s = r._popup) || void 0 === s || s.postMessage({
                    jsonrpc: "2.0",
                    id: n,
                    method: e,
                    params: t
                }, null !== (c = null === (a = r._providerUrl) || void 0 === a ? void 0 : a.origin) && void 0 !== c ? c : ""), r.autoApprove || null === (u = r._popup) || void 0 === u || u.focus())
            }))]
        }))
    }))
}, Object.defineProperty(t.prototype, "publicKey", {
    get: function() {
        return this._publicKey
    },
    enumerable: !1,
    configurable: !0
}), Object.defineProperty(t.prototype, "connected", {
    get: function() {
        return null !== this._publicKey
    },
    enumerable: !1,
    configurable: !0
}), Object.defineProperty(t.prototype, "autoApprove", {
    get: function() {
        return this._autoApprove
    },
    enumerable: !1,
    configurable: !0
}), t.prototype.connect = function() {
    return __awaiter(this, void 0, void 0, (function() {
        return __generator(this, (function(e) {
            switch (e.label) {
                case 0:
                    return this._popup && this._popup.close(), [4, this.handleConnect()];
                case 1:
                    return e.sent(), [2]
            }
        }))
    }))
}, t.prototype.disconnect = function() {
    return __awaiter(this, void 0, void 0, (function() {
        return __generator(this, (function(e) {
            switch (e.label) {
                case 0:
                    return this._injectedProvider ? [4, this.sendRequest("disconnect", {})] : [3, 2];
                case 1:
                    e.sent(), e.label = 2;
                case 2:
                    return this._popup && this._popup.close(), this.handleDisconnect(), [2]
            }
        }))
    }))
}, t.prototype.sign = function(e, t) {
    return __awaiter(this, void 0, void 0, (function() {
        var n, r, i;
        return __generator(this, (function(o) {
            switch (o.label) {
                case 0:
                    if (!(e instanceof Uint8Array)) throw new Error("Data must be an instance of Uint8Array");
                    return [4, this.sendRequest("sign", {
                        data: e,
                        display: t
                    })];
                case 1:
                    return n = o.sent(), r = bs58.decode(n.signature), i = new PublicKey(n.publicKey), [2, {
                        signature: r,
                        publicKey: i
                    }]
            }
        }))
    }))
}, t.prototype.signTransaction = function(e) {
    return __awaiter(this, void 0, void 0, (function() {
        var t, n, r;
        return __generator(this, (function(i) {
            switch (i.label) {
                case 0:
                    return [4, this.sendRequest("signTransaction", {
                        message: bs58.encode(e.serializeMessage())
                    })];
                case 1:
                    return t = i.sent(), n = bs58.decode(t.signature), r = new PublicKey(t.publicKey), e.addSignature(r, n), [2, e]
            }
        }))
    }))
}, t.prototype.signAllTransactions = function(e) {
    return __awaiter(this, void 0, void 0, (function() {
        var t, n, r;
        return __generator(this, (function(i) {
            switch (i.label) {
                case 0:
                    return [4, this.sendRequest("signAllTransactions", {
                        messages: e.map((function(e) {
                            return bs58.encode(e.serializeMessage())
                        }))
                    })];
                case 1:
                    return t = i.sent(), n = t.signatures.map((function(e) {
                        return bs58.decode(e)
                    })), r = new PublicKey(t.publicKey), [2, e = e.map((function(e, t) {
                        return e.addSignature(r, n[t]), e
                    }))]
            }
        }))
    }))
}, t.prototype.diffieHellman = function(e) {
    return __awaiter(this, void 0, void 0, (function() {
        return __generator(this, (function(t) {
            switch (t.label) {
                case 0:
                    if (!(e instanceof Uint8Array)) throw new Error("Data must be an instance of Uint8Array");
                    return [4, this.sendRequest("diffieHellman", {
                        publicKey: e
                    })];
                case 1:
                    return [2, t.sent()]
            }
        }))
    }))
}, t
}(EventEmitter);
window.Wallet;

function isString(e) {
return "string" == typeof e
}

function isInjectedProvider(e) {
return isObject(e) && "postMessage" in e && "function" == typeof e.postMessage
}

function isObject(e) {
return "object" == typeof e && null !== e
}
